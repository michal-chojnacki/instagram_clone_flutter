// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'init_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$InitStateTearOff {
  const _$InitStateTearOff();

// ignore: unused_element
  Idle idle() {
    return const Idle();
  }

// ignore: unused_element
  OpenLoginPage openLoginPage() {
    return const OpenLoginPage();
  }

// ignore: unused_element
  OpenContentPage openContentPage() {
    return const OpenContentPage();
  }
}

/// @nodoc
// ignore: unused_element
const $InitState = _$InitStateTearOff();

/// @nodoc
mixin _$InitState {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result idle(),
    @required Result openLoginPage(),
    @required Result openContentPage(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result idle(),
    Result openLoginPage(),
    Result openContentPage(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result idle(Idle value),
    @required Result openLoginPage(OpenLoginPage value),
    @required Result openContentPage(OpenContentPage value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result idle(Idle value),
    Result openLoginPage(OpenLoginPage value),
    Result openContentPage(OpenContentPage value),
    @required Result orElse(),
  });
}

/// @nodoc
abstract class $InitStateCopyWith<$Res> {
  factory $InitStateCopyWith(InitState value, $Res Function(InitState) then) =
      _$InitStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$InitStateCopyWithImpl<$Res> implements $InitStateCopyWith<$Res> {
  _$InitStateCopyWithImpl(this._value, this._then);

  final InitState _value;
  // ignore: unused_field
  final $Res Function(InitState) _then;
}

/// @nodoc
abstract class $IdleCopyWith<$Res> {
  factory $IdleCopyWith(Idle value, $Res Function(Idle) then) =
      _$IdleCopyWithImpl<$Res>;
}

/// @nodoc
class _$IdleCopyWithImpl<$Res> extends _$InitStateCopyWithImpl<$Res>
    implements $IdleCopyWith<$Res> {
  _$IdleCopyWithImpl(Idle _value, $Res Function(Idle) _then)
      : super(_value, (v) => _then(v as Idle));

  @override
  Idle get _value => super._value as Idle;
}

/// @nodoc
class _$Idle with DiagnosticableTreeMixin implements Idle {
  const _$Idle();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'InitState.idle()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'InitState.idle'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Idle);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result idle(),
    @required Result openLoginPage(),
    @required Result openContentPage(),
  }) {
    assert(idle != null);
    assert(openLoginPage != null);
    assert(openContentPage != null);
    return idle();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result idle(),
    Result openLoginPage(),
    Result openContentPage(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (idle != null) {
      return idle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result idle(Idle value),
    @required Result openLoginPage(OpenLoginPage value),
    @required Result openContentPage(OpenContentPage value),
  }) {
    assert(idle != null);
    assert(openLoginPage != null);
    assert(openContentPage != null);
    return idle(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result idle(Idle value),
    Result openLoginPage(OpenLoginPage value),
    Result openContentPage(OpenContentPage value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class Idle implements InitState {
  const factory Idle() = _$Idle;
}

/// @nodoc
abstract class $OpenLoginPageCopyWith<$Res> {
  factory $OpenLoginPageCopyWith(
          OpenLoginPage value, $Res Function(OpenLoginPage) then) =
      _$OpenLoginPageCopyWithImpl<$Res>;
}

/// @nodoc
class _$OpenLoginPageCopyWithImpl<$Res> extends _$InitStateCopyWithImpl<$Res>
    implements $OpenLoginPageCopyWith<$Res> {
  _$OpenLoginPageCopyWithImpl(
      OpenLoginPage _value, $Res Function(OpenLoginPage) _then)
      : super(_value, (v) => _then(v as OpenLoginPage));

  @override
  OpenLoginPage get _value => super._value as OpenLoginPage;
}

/// @nodoc
class _$OpenLoginPage with DiagnosticableTreeMixin implements OpenLoginPage {
  const _$OpenLoginPage();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'InitState.openLoginPage()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'InitState.openLoginPage'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is OpenLoginPage);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result idle(),
    @required Result openLoginPage(),
    @required Result openContentPage(),
  }) {
    assert(idle != null);
    assert(openLoginPage != null);
    assert(openContentPage != null);
    return openLoginPage();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result idle(),
    Result openLoginPage(),
    Result openContentPage(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (openLoginPage != null) {
      return openLoginPage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result idle(Idle value),
    @required Result openLoginPage(OpenLoginPage value),
    @required Result openContentPage(OpenContentPage value),
  }) {
    assert(idle != null);
    assert(openLoginPage != null);
    assert(openContentPage != null);
    return openLoginPage(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result idle(Idle value),
    Result openLoginPage(OpenLoginPage value),
    Result openContentPage(OpenContentPage value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (openLoginPage != null) {
      return openLoginPage(this);
    }
    return orElse();
  }
}

abstract class OpenLoginPage implements InitState {
  const factory OpenLoginPage() = _$OpenLoginPage;
}

/// @nodoc
abstract class $OpenContentPageCopyWith<$Res> {
  factory $OpenContentPageCopyWith(
          OpenContentPage value, $Res Function(OpenContentPage) then) =
      _$OpenContentPageCopyWithImpl<$Res>;
}

/// @nodoc
class _$OpenContentPageCopyWithImpl<$Res> extends _$InitStateCopyWithImpl<$Res>
    implements $OpenContentPageCopyWith<$Res> {
  _$OpenContentPageCopyWithImpl(
      OpenContentPage _value, $Res Function(OpenContentPage) _then)
      : super(_value, (v) => _then(v as OpenContentPage));

  @override
  OpenContentPage get _value => super._value as OpenContentPage;
}

/// @nodoc
class _$OpenContentPage
    with DiagnosticableTreeMixin
    implements OpenContentPage {
  const _$OpenContentPage();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'InitState.openContentPage()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'InitState.openContentPage'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is OpenContentPage);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result idle(),
    @required Result openLoginPage(),
    @required Result openContentPage(),
  }) {
    assert(idle != null);
    assert(openLoginPage != null);
    assert(openContentPage != null);
    return openContentPage();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result idle(),
    Result openLoginPage(),
    Result openContentPage(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (openContentPage != null) {
      return openContentPage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result idle(Idle value),
    @required Result openLoginPage(OpenLoginPage value),
    @required Result openContentPage(OpenContentPage value),
  }) {
    assert(idle != null);
    assert(openLoginPage != null);
    assert(openContentPage != null);
    return openContentPage(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result idle(Idle value),
    Result openLoginPage(OpenLoginPage value),
    Result openContentPage(OpenContentPage value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (openContentPage != null) {
      return openContentPage(this);
    }
    return orElse();
  }
}

abstract class OpenContentPage implements InitState {
  const factory OpenContentPage() = _$OpenContentPage;
}
